## 第一章 块级作用域绑定

### var声明及变量提升(Hoisting)机制

通过关键字var声明的变量，都会被当成在当前作用域顶部声明的变量。

#### 块级声明

块级作用域存在于：

- 函数内部
- 块中（用大括号{}分隔）  

用let来声明变量，就可以把变量的作用域限制在当前代码块中。let声明不会被提升，所以通常将let声明语句放在封闭代码块的顶部。

#### 禁止重声明

同一作用域中不能用let重复定义已经存在的标识符，但是可以在内嵌作用域中let声明上一层作用域的同名变量。

#### const声明

const声明的是常量，其值一旦被设定后不可更改（其实是不可修改指针的指向。如果指向对象，则对象的值是可以修改的），因此**const声明的同时必须进行初始化**。

#### 临时死区(Temporal Dead Zone)

let和const声明的变量不会提升到作用域顶部，如果在声明之前访问这些变量，会触发ReferenceError（即使是相对安全的typeof操作符）。  

JavaScript引擎在扫描代码发现变量声明时，要么将它们提升至作用域顶部（var），要么将声明放到TDZ中（let和const）。对于TDZ中的变量，只有执行过变量声明语句后，变量才会从TDZ中移出，可以正常访问。



### 循环块中的块作用域绑定

对于循环`for(let i=0; i < num; i++)`中声明的变量`i`，只会在循环中才能访问到，同时每一次循环都是产生一个唯一的变量副本，并不会复用（避免了异步回调时候的取值问题）。  

它的作用类似于使用IIFE对其进行再一层的包装，从而获得一个局部作用域内的变量副本，不与外部共享，保证了取值的正确。  

const也可以用于循环，只是在循环中不能修改它的指向。  



### 全局块作用域绑定

var用于全局作用域时，会创建一个全新的全局变量作为全局对象（window或global）的属性，也就是说var可能会覆盖已经存在的全局属性。  

**let和const用于全局作用域，会创建一个新的绑定，但该绑定不会添加为全局对象的属性。**它会遮蔽全局的同名属性，但是依然可以使用window.attributeName的形式去获取到原本的属性。



### 块级绑定最佳实践的进化

默认使用const，只在确实需要改变变量的值时使用let。

