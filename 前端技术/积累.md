## SSR

SSR的基本思路为：

1. 建立MVVM模型，提供服务端和客户端的通用渲染入口，配置对应的组件和依赖。由于前端代码通常使用ES6+的语法书写，需要进行ES5转译（babel或typescript），并按需添加 polyfill 依赖（core-js）。
2. 基于通用渲染入口，分别提供服务端和客户端使用的入口。注意根据需要，分别配置构建流程，比较显著的差异有：
  - target：服务端为面向CommanJS，客户端为ES5
  - dynamic import：客户端要特别注意组件和模块的chunk化处理，面向路由路径和组件打包chunk。
  - PWA适配：如有条件，考虑生成面向客户端的manifest.json
  - watch模式：便于开发，服务端需配置好构建工具的watch命令
3. 服务端根据请求，通过上游接口获取对应数据，并根据对应页面模板，生成初始html页面（可能是skeleton）。初始页面的生成可能要考虑store、router等依赖的协作，需要对其进行初始化。
4. 将MVVM模型的`window.__INITIAL_STATE__`通过`<script>`写入，提供给客户端激活使用。
5. 配置相关的静态资源。
6. 返回页面，用户侧加载相关资源。
7. 客户端显示初始页面后，执行MVVM激活操作：首先从`window.__INITIAL_STATE__`中获取初始状态，初始化store、router等依赖；然后客户端初始化MVVM模型，将模型中的数据进行初始化；最后执行混合（hydrate）操作，使用客户端的真实节点替代服务端渲染的内容，并接管对应的事件交互。




## 杂项
1. 基于nginx的concat，实现资源请求的combo模式，减少请求并发量。
2. 

